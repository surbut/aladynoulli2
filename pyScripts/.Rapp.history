function(plot_data) {#
  # Limit to top 16 diseases by dynamic AUC#
  top_diseases <- plot_data %>%#
    filter(model == "Aladynoulli Dynamic") %>%#
    arrange(desc(Events)) %>%#
    head(16) %>%#
    pull(Disease)#
  plot_data_subset <- plot_data %>%#
    filter(Disease %in% top_diseases)#
#
  plot_data_subset$Disease <- factor(plot_data_subset$Disease, levels = top_diseases)#
  plot_data_subset=plot_data%>%#
    filter(Disease %in% c("ASCVD","Diabetes","Breast_Cancer","COPD","Atrial_Fib","Prostate_Cancer","Osteoporosis",#
                          "Parkinsons","CKD","Heart_Failure","Rheumatoid_Arthritis","Colorectal_Cancer"))#
  # Define colors for models, now including TD Cox#
  model_colors <- c(#
    "Time-dependent Cox with Noulli" = "#8E44AD",   # Purple#
    "Aladynoulli Dynamic" = "#4285F4",              # Blue#
    "Aladynoulli Static" = "#34A853",               # Green#
    "Cox with Noulli" = "#EA4335",                  # Red#
    "Cox without Noulli" = "#FBBC05"                # Yellow/Orange#
  )#
  # Create the faceted plot#
  p <- ggplot(plot_data_subset, aes(x = model, y = auc, color = model)) +#
    geom_point(size = 2) +#
    geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1) +#
    facet_wrap(~ Disease, scales = "free_y", ncol = 4) +#
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray70") +#
    scale_color_manual(values = model_colors) +#
    scale_y_continuous(limits = c(0.3, 1), breaks = seq(0.3, 1, by = 0.1)) +#
    labs(#
      title = "Multi-Disease AUC Comparison",#
      subtitle = "Performance across top 16 diseases",#
      y = "AUC (95% CI)",#
      x = NULL#
    ) +#
    theme_minimal() +#
    theme(#
      legend.position = "top",#
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),#
      strip.text = element_text(face = "bold"),#
      plot.title = element_text(size = 14, face = "bold"),#
      plot.subtitle = element_text(size = 12)#
    )#
  return(p)#
}
model_data <- parse_model_data("all_model_comp_withtdcox.csv")#
plot_data <- prepare_forest_plot_data(model_data)#
#
# Add this line to also generate the faceted plot#
faceted_plot <- create_faceted_forest_plot(plot_data)#
ggsave("multidisease_faceted_plot.pdf", faceted_plot, width = 12, height = 12, dpi = 300)
# Load required libraries#
library(ggplot2)#
library(dplyr)#
library(tidyr)#
library(stringr)#
library(forcats)#
#
# Function to parse the data#
parse_model_data <- function(data_path) {#
  # Read the data#
  df <- read.csv(data_path)#
  # Extract confidence intervals from the formatted strings#
  extract_ci <- function(ci_str) {#
    # Matches format like "0.765 (0.748-0.782)"#
    pattern <- "(\\d+\\.\\d+)\\s*\\((\\d+\\.\\d+)-(\\d+\\.\\d+)\\)"#
    matches <- regexec(pattern, ci_str)#
    result <- regmatches(ci_str, matches)#
    if(length(result) > 0 && length(result[[1]]) >= 4) {#
      return(c(as.numeric(result[[1]][2]), #
               as.numeric(result[[1]][3]),#
               as.numeric(result[[1]][4])))#
    } else {#
      return(c(NA, NA, NA))#
    }#
  }#
  # Create a clean data frame#
  model_data <- data.frame(#
    Disease = df$Disease,#
    Events = df$Events,#
    Rate = df$Rate,#
    stringsAsFactors = FALSE#
  )#
  # Extract values for Aladynoulli Dynamic#
  dynamic_ci <- lapply(df$aladynoulli_auc_dynamic, extract_ci)#
  model_data$dynamic_auc <- sapply(dynamic_ci, function(x) x[1])#
  model_data$dynamic_lower <- sapply(dynamic_ci, function(x) x[2])#
  model_data$dynamic_upper <- sapply(dynamic_ci, function(x) x[3])#
  # Extract values for Aladynoulli Static#
  static_ci <- lapply(df$aladynoulli_auc_static, extract_ci)#
  model_data$static_auc <- sapply(static_ci, function(x) x[1])#
  model_data$static_lower <- sapply(static_ci, function(x) x[2])#
  model_data$static_upper <- sapply(static_ci, function(x) x[3])#
  # Add Cox values#
  model_data$cox_without_noulli <- df$cox_auc_without_noulli#
  model_data$cox_with_noulli <- df$cox_auc_with_noulli#
#
  # Add TD Cox AUC (as numeric)#
  model_data$td_cox_auc <- as.numeric(df$td_cox)#
  # Calculate CI for Cox values (using the formula SE = sqrt((AUC * (1-AUC)) / (n * prevalence)))#
  calc_cox_ci <- function(auc, events, total = 400000) {#
    prevalence <- events / total#
    prevalence <- max(0.01, prevalence)#
    se <- sqrt((auc * (1 - auc)) / (total * prevalence))#
    lower <- max(0, auc - 1.96 * se)#
    upper <- min(1, auc + 1.96 * se)#
    return(c(lower, upper))#
  }#
  # Add CI for Cox without Noulli#
  cox_without_ci <- mapply(calc_cox_ci, #
                           model_data$cox_without_noulli, #
                           model_data$Events, #
                           SIMPLIFY = FALSE)#
  model_data$cox_without_lower <- sapply(cox_without_ci, function(x) x[1])#
  model_data$cox_without_upper <- sapply(cox_without_ci, function(x) x[2])#
  # Add CI for Cox with Noulli#
  cox_with_ci <- mapply(calc_cox_ci, #
                        model_data$cox_with_noulli, #
                        model_data$Events, #
                        SIMPLIFY = FALSE)#
  model_data$cox_with_lower <- sapply(cox_with_ci, function(x) x[1])#
  model_data$cox_with_upper <- sapply(cox_with_ci, function(x) x[2])#
#
  # Add CI for TD Cox#
  td_cox_ci <- mapply(calc_cox_ci, #
                      model_data$td_cox_auc, #
                      model_data$Events, #
                      SIMPLIFY = FALSE)#
  model_data$td_cox_lower <- sapply(td_cox_ci, function(x) x[1])#
  model_data$td_cox_upper <- sapply(td_cox_ci, function(x) x[2])#
  # Calculate CI for Aladynoulli Dynamic using actual sample size (e.g., 400,000)#
  aladyn_dynamic_ci <- mapply(calc_cox_ci, #
                            model_data$dynamic_auc, #
                            model_data$Events, #
                            MoreArgs = list(total = 400000), #
                            SIMPLIFY = FALSE)#
  model_data$dynamic_lower <- sapply(aladyn_dynamic_ci, function(x) x[1])#
  model_data$dynamic_upper <- sapply(aladyn_dynamic_ci, function(x) x[2])#
#
  # Calculate CI for Aladynoulli Static using actual sample size (e.g., 400,000)#
  aladyn_static_ci <- mapply(calc_cox_ci, #
                           model_data$static_auc, #
                           model_data$Events, #
                           MoreArgs = list(total = 400000), #
                           SIMPLIFY = FALSE)#
  model_data$static_lower <- sapply(aladyn_static_ci, function(x) x[1])#
  model_data$static_upper <- sapply(aladyn_static_ci, function(x) x[2])#
  # Extract values for Aladynoulli 1-year#
  one_year_ci <- lapply(df$Dynamic1year, extract_ci)#
  model_data$one_year_auc <- sapply(one_year_ci, function(x) x[1])#
  model_data$one_year_lower <- sapply(one_year_ci, function(x) x[2])#
  model_data$one_year_upper <- sapply(one_year_ci, function(x) x[3])#
  # After extracting one_year_auc, one_year_lower, one_year_upper, add CI calculation for 1-year AUC using total=400000#
  one_year_ci_calc <- mapply(calc_cox_ci, #
                          model_data$one_year_auc, #
                          model_data$Events, #
                          MoreArgs = list(total = 400000), #
                          SIMPLIFY = FALSE)#
  model_data$one_year_lower <- sapply(one_year_ci_calc, function(x) x[1])#
  model_data$one_year_upper <- sapply(one_year_ci_calc, function(x) x[2])#
  return(model_data)#
}
# Load required libraries#
library(ggplot2)#
library(dplyr)#
library(tidyr)#
library(stringr)#
library(forcats)#
#
# Function to parse the data#
parse_model_data <- function(data_path) {#
  # Read the data#
  df <- read.csv(data_path)#
  # Extract confidence intervals from the formatted strings#
  extract_ci <- function(ci_str) {#
    # Matches format like "0.765 (0.748-0.782)"#
    pattern <- "(\\d+\\.\\d+)\\s*\\((\\d+\\.\\d+)-(\\d+\\.\\d+)\\)"#
    matches <- regexec(pattern, ci_str)#
    result <- regmatches(ci_str, matches)#
    if(length(result) > 0 && length(result[[1]]) >= 4) {#
      return(c(as.numeric(result[[1]][2]), #
               as.numeric(result[[1]][3]),#
               as.numeric(result[[1]][4])))#
    } else {#
      return(c(NA, NA, NA))#
    }#
  }#
  # Create a clean data frame#
  model_data <- data.frame(#
    Disease = df$Disease,#
    Events = df$Events,#
    Rate = df$Rate,#
    stringsAsFactors = FALSE#
  )#
  # Extract values for Aladynoulli Dynamic#
  dynamic_ci <- lapply(df$aladynoulli_auc_dynamic, extract_ci)#
  model_data$dynamic_auc <- sapply(dynamic_ci, function(x) x[1])#
  model_data$dynamic_lower <- sapply(dynamic_ci, function(x) x[2])#
  model_data$dynamic_upper <- sapply(dynamic_ci, function(x) x[3])#
  # Extract values for Aladynoulli Static#
  static_ci <- lapply(df$aladynoulli_auc_static, extract_ci)#
  model_data$static_auc <- sapply(static_ci, function(x) x[1])#
  model_data$static_lower <- sapply(static_ci, function(x) x[2])#
  model_data$static_upper <- sapply(static_ci, function(x) x[3])#
  # Add Cox values#
  model_data$cox_without_noulli <- df$cox_auc_without_noulli#
  model_data$cox_with_noulli <- df$cox_auc_with_noulli#
#
  # Add TD Cox AUC (as numeric)#
  model_data$td_cox_auc <- as.numeric(df$td_cox)#
  # Calculate CI for Cox values (using the formula SE = sqrt((AUC * (1-AUC)) / (n * prevalence)))#
  calc_cox_ci <- function(auc, events, total = 400000) {#
    prevalence <- events / total#
    prevalence <- max(0.01, prevalence)#
    se <- sqrt((auc * (1 - auc)) / (total * prevalence))#
    lower <- max(0, auc - 1.96 * se)#
    upper <- min(1, auc + 1.96 * se)#
    return(c(lower, upper))#
  }#
  # Add CI for Cox without Noulli#
  cox_without_ci <- mapply(calc_cox_ci, #
                           model_data$cox_without_noulli, #
                           model_data$Events, #
                           SIMPLIFY = FALSE)#
  model_data$cox_without_lower <- sapply(cox_without_ci, function(x) x[1])#
  model_data$cox_without_upper <- sapply(cox_without_ci, function(x) x[2])#
  # Add CI for Cox with Noulli#
  cox_with_ci <- mapply(calc_cox_ci, #
                        model_data$cox_with_noulli, #
                        model_data$Events, #
                        SIMPLIFY = FALSE)#
  model_data$cox_with_lower <- sapply(cox_with_ci, function(x) x[1])#
  model_data$cox_with_upper <- sapply(cox_with_ci, function(x) x[2])#
#
  # Add CI for TD Cox#
  td_cox_ci <- mapply(calc_cox_ci, #
                      model_data$td_cox_auc, #
                      model_data$Events, #
                      SIMPLIFY = FALSE)#
  model_data$td_cox_lower <- sapply(td_cox_ci, function(x) x[1])#
  model_data$td_cox_upper <- sapply(td_cox_ci, function(x) x[2])#
  # Calculate CI for Aladynoulli Dynamic using actual sample size (e.g., 400,000)#
  aladyn_dynamic_ci <- mapply(calc_cox_ci, #
                            model_data$dynamic_auc, #
                            model_data$Events, #
                            MoreArgs = list(total = 400000), #
                            SIMPLIFY = FALSE)#
  model_data$dynamic_lower <- sapply(aladyn_dynamic_ci, function(x) x[1])#
  model_data$dynamic_upper <- sapply(aladyn_dynamic_ci, function(x) x[2])#
#
  # Calculate CI for Aladynoulli Static using actual sample size (e.g., 400,000)#
  aladyn_static_ci <- mapply(calc_cox_ci, #
                           model_data$static_auc, #
                           model_data$Events, #
                           MoreArgs = list(total = 400000), #
                           SIMPLIFY = FALSE)#
  model_data$static_lower <- sapply(aladyn_static_ci, function(x) x[1])#
  model_data$static_upper <- sapply(aladyn_static_ci, function(x) x[2])#
  # Extract values for Aladynoulli 1-year#
  one_year_ci <- lapply(df$Dynamic1year, extract_ci)#
  model_data$one_year_auc <- sapply(one_year_ci, function(x) x[1])#
  model_data$one_year_lower <- sapply(one_year_ci, function(x) x[2])#
  model_data$one_year_upper <- sapply(one_year_ci, function(x) x[3])#
  # After extracting one_year_auc, one_year_lower, one_year_upper, add CI calculation for 1-year AUC using total=400000#
  one_year_ci_calc <- mapply(calc_cox_ci, #
                          model_data$one_year_auc, #
                          model_data$Events, #
                          MoreArgs = list(total = 400000), #
                          SIMPLIFY = FALSE)#
  model_data$one_year_lower <- sapply(one_year_ci_calc, function(x) x[1])#
  model_data$one_year_upper <- sapply(one_year_ci_calc, function(x) x[2])#
  return(model_data)#
}#
#
# Reshape data for plotting#
prepare_forest_plot_data <- function(model_data) {#
  # Transform to long format, now including TD Cox#
  long_data <- model_data %>%#
    pivot_longer(#
      cols = c("one_year_auc", "td_cox_auc", "dynamic_auc", "static_auc", "cox_with_noulli", "cox_without_noulli"),#
      names_to = "model",#
      values_to = "auc"#
    ) %>%#
    mutate(#
      lower = case_when(#
        model == "one_year_auc" ~ one_year_lower,#
        model == "td_cox_auc" ~ td_cox_lower,#
        model == "dynamic_auc" ~ dynamic_lower,#
        model == "static_auc" ~ static_lower,#
        model == "cox_with_noulli" ~ cox_with_lower,#
        model == "cox_without_noulli" ~ cox_without_lower#
      ),#
      upper = case_when(#
        model == "one_year_auc" ~ one_year_upper,#
        model == "td_cox_auc" ~ td_cox_upper,#
        model == "dynamic_auc" ~ dynamic_upper,#
        model == "static_auc" ~ static_upper,#
        model == "cox_with_noulli" ~ cox_with_upper,#
        model == "cox_without_noulli" ~ cox_without_upper#
      ),#
      model = case_when(#
        model == "one_year_auc" ~ "Aladynoulli 1-year",#
        model == "td_cox_auc" ~ "Time-dependent Cox with Noulli",#
        model == "dynamic_auc" ~ "Aladynoulli Dynamic",#
        model == "static_auc" ~ "Aladynoulli Static",#
        model == "cox_with_noulli" ~ "Cox with Noulli",#
        model == "cox_without_noulli" ~ "Cox without Noulli"#
      )#
    ) %>%#
    select(Disease, Events, Rate, model, auc, lower, upper)#
  # Set the model order with 'Aladynoulli 1-year' as the far left#
  long_data$model <- factor(long_data$model, levels = c(#
    "Aladynoulli 1-year",#
    "Time-dependent Cox with Noulli",#
    "Aladynoulli Dynamic",#
    "Aladynoulli Static",#
    "Cox with Noulli",#
    "Cox without Noulli"#
  ))#
  # Make Disease a factor ordered by dynamic AUC#
  disease_order <- model_data %>%#
    arrange(desc(dynamic_auc)) %>%#
    pull(Disease)#
  long_data$Disease <- factor(long_data$Disease, levels = disease_order)#
  return(long_data)#
}#
#
# Create the forest plot#
create_forest_plot <- function(plot_data) {#
  # Define colors for models#
  model_colors <- c(#
    "Aladynoulli 1-year" = "#222222", # Black or dark gray#
    "Time-dependent Cox with Noulli" = "#8E44AD",   # Purple#
    "Aladynoulli Dynamic" = "#4285F4",              # Blue#
    "Aladynoulli Static" = "#34A853",               # Green#
    "Cox with Noulli" = "#EA4335",                  # Red#
    "Cox without Noulli" = "#FBBC05"                # Yellow/Orange#
  )#
  # Shape the disease names to be more readable#
  plot_data <- plot_data %>%#
    mutate(Disease = str_replace_all(Disease, "_", " "))#
#
  # Create the plot#
  p <- ggplot(plot_data, aes(x = auc, y = Disease, color = model)) +#
    geom_vline(xintercept = 0.5, linetype = "dashed", color = "gray70") +#
    geom_point(aes(shape = model), size = 2.5, position = position_dodge(width = 0.5)) +#
    geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0.2, position = position_dodge(width = 0.5)) +#
    scale_color_manual(values = model_colors) +#
    scale_x_continuous(limits = c(0.3, 1), breaks = seq(0.3, 1, by = 0.1)) +#
    labs(#
      title = "Multi-Disease AUC Comparison",#
      subtitle = "Comparing performance of four prediction models across 28 diseases",#
      x = "AUC (95% CI)",#
      y = NULL,#
      color = "Model",#
      shape = "Model"#
    ) +#
    theme_minimal() +#
    theme(#
      legend.position = "top",#
      panel.grid.major.y = element_line(color = "gray90"),#
      panel.grid.minor.y = element_blank(),#
      axis.text.y = element_text(size = 10),#
      plot.title = element_text(size = 14, face = "bold"),#
      plot.subtitle = element_text(size = 12)#
    )#
  return(p)#
}#
#
# Main function to run the analysis#
create_multidisease_comparison <- function(data_path) {#
  # Parse the data#
  model_data <- parse_model_data(data_path)#
  # Prepare data for plotting#
  plot_data <- prepare_forest_plot_data(model_data)#
  # Create forest plot#
  forest_plot <- create_forest_plot(plot_data)#
  # Save the plot#
  ggsave("multidisease_forest_plot.png", forest_plot, width = 12, height = 14, dpi = 300)#
  # Print summary statistics#
  model_summary <- plot_data %>%#
    group_by(model) %>%#
    summarize(#
      mean_auc = mean(auc, na.rm = TRUE),#
      median_auc = median(auc, na.rm = TRUE),#
      min_auc = min(auc, na.rm = TRUE),#
      max_auc = max(auc, na.rm = TRUE)#
    )#
  print(model_summary)#
  return(forest_plot)#
}#
#
# Example usage:#
# forest_plot <- create_multidisease_comparison("model_comparison_everything.csv")#
# print(forest_plot)#
#
# Alternative approach with facet_wrap for separate panels by disease#
create_faceted_forest_plot <- function(plot_data) {#
  # Limit to top 16 diseases by dynamic AUC#
  top_diseases <- plot_data %>%#
    filter(model == "Aladynoulli Dynamic") %>%#
    arrange(desc(Events)) %>%#
    head(16) %>%#
    pull(Disease)#
  plot_data_subset <- plot_data %>%#
    filter(Disease %in% top_diseases)#
#
  plot_data_subset$Disease <- factor(plot_data_subset$Disease, levels = top_diseases)#
  plot_data_subset=plot_data%>%#
    filter(Disease %in% c("ASCVD","Diabetes","Breast_Cancer","COPD","Atrial_Fib","Prostate_Cancer","Osteoporosis",#
                          "Parkinsons","CKD","Heart_Failure","Rheumatoid_Arthritis","Stroke"))#
  # Define colors for models, now including TD Cox#
  model_colors <- c(#
    "Aladynoulli 1-year" = "#222222", # Black or dark gray#
    "Time-dependent Cox with Noulli" = "#8E44AD",   # Purple#
    "Aladynoulli Dynamic" = "#4285F4",              # Blue#
    "Aladynoulli Static" = "#34A853",               # Green#
    "Cox with Noulli" = "#EA4335",                  # Red#
    "Cox without Noulli" = "#FBBC05"                # Yellow/Orange#
  )#
  # Create the faceted plot#
  p <- ggplot(plot_data_subset, aes(x = model, y = auc, color = model)) +#
    geom_point(size = 2) +#
    geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1) +#
    facet_wrap(~ Disease, scales = "free_y", ncol = 4) +#
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray70") +#
    scale_color_manual(values = model_colors) +#
    scale_y_continuous(limits = c(0.3, 1), breaks = seq(0.3, 1, by = 0.1)) +#
    labs(#
      title = "Multi-Disease AUC Comparison",#
      subtitle = "Performance across top 16 diseases",#
      y = "AUC (95% CI)",#
      x = NULL#
    ) +#
    theme_minimal() +#
    theme(#
      legend.position = "top",#
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),#
      strip.text = element_text(face = "bold"),#
      plot.title = element_text(size = 14, face = "bold"),#
      plot.subtitle = element_text(size = 12)#
    )#
  return(p)#
}
model_data <- parse_model_data("all_model_comp_withtdcox2.csv")#
plot_data <- prepare_forest_plot_data(model_data)#
#
# Add this line to also generate the faceted plot#
faceted_plot <- create_faceted_forest_plot(plot_data)#
ggsave("multidisease_faceted_plot.pdf", faceted_plot, width = 12, height = 12, dpi = 300)#
# Function for time-dependent Cox modeling
# Load required libraries#
library(ggplot2)#
library(dplyr)#
library(tidyr)#
library(stringr)#
library(forcats)#
#
# Function to parse the data#
parse_model_data <- function(data_path) {#
  # Read the data#
  df <- read.csv(data_path)#
  # Extract confidence intervals from the formatted strings#
  extract_ci <- function(ci_str) {#
    # Matches format like "0.765 (0.748-0.782)"#
    pattern <- "(\\d+\\.\\d+)\\s*\\((\\d+\\.\\d+)-(\\d+\\.\\d+)\\)"#
    matches <- regexec(pattern, ci_str)#
    result <- regmatches(ci_str, matches)#
    if(length(result) > 0 && length(result[[1]]) >= 4) {#
      return(c(as.numeric(result[[1]][2]), #
               as.numeric(result[[1]][3]),#
               as.numeric(result[[1]][4])))#
    } else {#
      return(c(NA, NA, NA))#
    }#
  }#
  # Create a clean data frame#
  model_data <- data.frame(#
    Disease = df$Disease,#
    Events = df$Events,#
    Rate = df$Rate,#
    stringsAsFactors = FALSE#
  )#
  # Extract values for Aladynoulli Dynamic#
  dynamic_ci <- lapply(df$aladynoulli_auc_dynamic, extract_ci)#
  model_data$dynamic_auc <- sapply(dynamic_ci, function(x) x[1])#
  model_data$dynamic_lower <- sapply(dynamic_ci, function(x) x[2])#
  model_data$dynamic_upper <- sapply(dynamic_ci, function(x) x[3])#
  # Extract values for Aladynoulli Static#
  static_ci <- lapply(df$aladynoulli_auc_static, extract_ci)#
  model_data$static_auc <- sapply(static_ci, function(x) x[1])#
  model_data$static_lower <- sapply(static_ci, function(x) x[2])#
  model_data$static_upper <- sapply(static_ci, function(x) x[3])#
  # Add Cox values#
  model_data$cox_without_noulli <- df$cox_auc_without_noulli#
  model_data$cox_with_noulli <- df$cox_auc_with_noulli#
#
  # Add TD Cox AUC (as numeric)#
  model_data$td_cox_auc <- as.numeric(df$td_cox)#
  # Calculate CI for Cox values (using the formula SE = sqrt((AUC * (1-AUC)) / (n * prevalence)))#
  calc_cox_ci <- function(auc, events, total = 400000) {#
    prevalence <- events / total#
    prevalence <- max(0.01, prevalence)#
    se <- sqrt((auc * (1 - auc)) / (total * prevalence))#
    lower <- max(0, auc - 1.96 * se)#
    upper <- min(1, auc + 1.96 * se)#
    return(c(lower, upper))#
  }#
  # Add CI for Cox without Noulli#
  cox_without_ci <- mapply(calc_cox_ci, #
                           model_data$cox_without_noulli, #
                           model_data$Events, #
                           SIMPLIFY = FALSE)#
  model_data$cox_without_lower <- sapply(cox_without_ci, function(x) x[1])#
  model_data$cox_without_upper <- sapply(cox_without_ci, function(x) x[2])#
  # Add CI for Cox with Noulli#
  cox_with_ci <- mapply(calc_cox_ci, #
                        model_data$cox_with_noulli, #
                        model_data$Events, #
                        SIMPLIFY = FALSE)#
  model_data$cox_with_lower <- sapply(cox_with_ci, function(x) x[1])#
  model_data$cox_with_upper <- sapply(cox_with_ci, function(x) x[2])#
#
  # Add CI for TD Cox#
  td_cox_ci <- mapply(calc_cox_ci, #
                      model_data$td_cox_auc, #
                      model_data$Events, #
                      SIMPLIFY = FALSE)#
  model_data$td_cox_lower <- sapply(td_cox_ci, function(x) x[1])#
  model_data$td_cox_upper <- sapply(td_cox_ci, function(x) x[2])#
  # Calculate CI for Aladynoulli Dynamic using actual sample size (e.g., 400,000)#
  aladyn_dynamic_ci <- mapply(calc_cox_ci, #
                            model_data$dynamic_auc, #
                            model_data$Events, #
                            MoreArgs = list(total = 400000), #
                            SIMPLIFY = FALSE)#
  model_data$dynamic_lower <- sapply(aladyn_dynamic_ci, function(x) x[1])#
  model_data$dynamic_upper <- sapply(aladyn_dynamic_ci, function(x) x[2])#
#
  # Calculate CI for Aladynoulli Static using actual sample size (e.g., 400,000)#
  aladyn_static_ci <- mapply(calc_cox_ci, #
                           model_data$static_auc, #
                           model_data$Events, #
                           MoreArgs = list(total = 400000), #
                           SIMPLIFY = FALSE)#
  model_data$static_lower <- sapply(aladyn_static_ci, function(x) x[1])#
  model_data$static_upper <- sapply(aladyn_static_ci, function(x) x[2])#
  # Combine the two columns into one string#
  one_year_combined <- paste0(df$Dynamic1year, " ", trimws(df[[which(names(df) == "Dynamic1year") + 1]]))#
  one_year_ci <- lapply(one_year_combined, extract_ci)#
  model_data$one_year_auc <- sapply(one_year_ci, function(x) x[1])#
  model_data$one_year_lower <- sapply(one_year_ci, function(x) x[2])#
  model_data$one_year_upper <- sapply(one_year_ci, function(x) x[3])#
  # After extracting one_year_auc, one_year_lower, one_year_upper, add CI calculation for 1-year AUC using total=400000#
  one_year_ci_calc <- mapply(calc_cox_ci, #
                          model_data$one_year_auc, #
                          model_data$Events, #
                          MoreArgs = list(total = 400000), #
                          SIMPLIFY = FALSE)#
  model_data$one_year_lower <- sapply(one_year_ci_calc, function(x) x[1])#
  model_data$one_year_upper <- sapply(one_year_ci_calc, function(x) x[2])#
  return(model_data)#
}#
#
# Reshape data for plotting#
prepare_forest_plot_data <- function(model_data) {#
  # Transform to long format, now including TD Cox#
  long_data <- model_data %>%#
    pivot_longer(#
      cols = c("one_year_auc", "td_cox_auc", "dynamic_auc", "static_auc", "cox_with_noulli", "cox_without_noulli"),#
      names_to = "model",#
      values_to = "auc"#
    ) %>%#
    mutate(#
      lower = case_when(#
        model == "one_year_auc" ~ one_year_lower,#
        model == "td_cox_auc" ~ td_cox_lower,#
        model == "dynamic_auc" ~ dynamic_lower,#
        model == "static_auc" ~ static_lower,#
        model == "cox_with_noulli" ~ cox_with_lower,#
        model == "cox_without_noulli" ~ cox_without_lower#
      ),#
      upper = case_when(#
        model == "one_year_auc" ~ one_year_upper,#
        model == "td_cox_auc" ~ td_cox_upper,#
        model == "dynamic_auc" ~ dynamic_upper,#
        model == "static_auc" ~ static_upper,#
        model == "cox_with_noulli" ~ cox_with_upper,#
        model == "cox_without_noulli" ~ cox_without_upper#
      ),#
      model = case_when(#
        model == "one_year_auc" ~ "Aladynoulli 1-year",#
        model == "td_cox_auc" ~ "Time-dependent Cox with Noulli",#
        model == "dynamic_auc" ~ "Aladynoulli Dynamic",#
        model == "static_auc" ~ "Aladynoulli Static",#
        model == "cox_with_noulli" ~ "Cox with Noulli",#
        model == "cox_without_noulli" ~ "Cox without Noulli"#
      )#
    ) %>%#
    select(Disease, Events, Rate, model, auc, lower, upper)#
  # Set the model order with 'Aladynoulli 1-year' as the far left#
  long_data$model <- factor(long_data$model, levels = c(#
    "Aladynoulli 1-year",#
    "Time-dependent Cox with Noulli",#
    "Aladynoulli Dynamic",#
    "Aladynoulli Static",#
    "Cox with Noulli",#
    "Cox without Noulli"#
  ))#
  # Make Disease a factor ordered by dynamic AUC#
  disease_order <- model_data %>%#
    arrange(desc(dynamic_auc)) %>%#
    pull(Disease)#
  long_data$Disease <- factor(long_data$Disease, levels = disease_order)#
  return(long_data)#
}#
#
# Create the forest plot#
create_forest_plot <- function(plot_data) {#
  # Define colors for models#
  model_colors <- c(#
    "Aladynoulli 1-year" = "#222222", # Black or dark gray#
    "Time-dependent Cox with Noulli" = "#8E44AD",   # Purple#
    "Aladynoulli Dynamic" = "#4285F4",              # Blue#
    "Aladynoulli Static" = "#34A853",               # Green#
    "Cox with Noulli" = "#EA4335",                  # Red#
    "Cox without Noulli" = "#FBBC05"                # Yellow/Orange#
  )#
  # Shape the disease names to be more readable#
  plot_data <- plot_data %>%#
    mutate(Disease = str_replace_all(Disease, "_", " "))#
#
  # Create the plot#
  p <- ggplot(plot_data, aes(x = auc, y = Disease, color = model)) +#
    geom_vline(xintercept = 0.5, linetype = "dashed", color = "gray70") +#
    geom_point(aes(shape = model), size = 2.5, position = position_dodge(width = 0.5)) +#
    geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0.2, position = position_dodge(width = 0.5)) +#
    scale_color_manual(values = model_colors) +#
    scale_x_continuous(limits = c(0.3, 1), breaks = seq(0.3, 1, by = 0.1)) +#
    labs(#
      title = "Multi-Disease AUC Comparison",#
      subtitle = "Comparing performance of four prediction models across 28 diseases",#
      x = "AUC (95% CI)",#
      y = NULL,#
      color = "Model",#
      shape = "Model"#
    ) +#
    theme_minimal() +#
    theme(#
      legend.position = "top",#
      panel.grid.major.y = element_line(color = "gray90"),#
      panel.grid.minor.y = element_blank(),#
      axis.text.y = element_text(size = 10),#
      plot.title = element_text(size = 14, face = "bold"),#
      plot.subtitle = element_text(size = 12)#
    )#
  return(p)#
}#
#
# Main function to run the analysis#
create_multidisease_comparison <- function(data_path) {#
  # Parse the data#
  model_data <- parse_model_data(data_path)#
  # Prepare data for plotting#
  plot_data <- prepare_forest_plot_data(model_data)#
  # Create forest plot#
  forest_plot <- create_forest_plot(plot_data)#
  # Save the plot#
  ggsave("multidisease_forest_plot.png", forest_plot, width = 12, height = 14, dpi = 300)#
  # Print summary statistics#
  model_summary <- plot_data %>%#
    group_by(model) %>%#
    summarize(#
      mean_auc = mean(auc, na.rm = TRUE),#
      median_auc = median(auc, na.rm = TRUE),#
      min_auc = min(auc, na.rm = TRUE),#
      max_auc = max(auc, na.rm = TRUE)#
    )#
  print(model_summary)#
  return(forest_plot)#
}#
#
# Example usage:#
# forest_plot <- create_multidisease_comparison("model_comparison_everything.csv")#
# print(forest_plot)#
#
# Alternative approach with facet_wrap for separate panels by disease#
create_faceted_forest_plot <- function(plot_data) {#
  # Limit to top 16 diseases by dynamic AUC#
  top_diseases <- plot_data %>%#
    filter(model == "Aladynoulli Dynamic") %>%#
    arrange(desc(Events)) %>%#
    head(16) %>%#
    pull(Disease)#
  plot_data_subset <- plot_data %>%#
    filter(Disease %in% top_diseases)#
#
  plot_data_subset$Disease <- factor(plot_data_subset$Disease, levels = top_diseases)#
plot_data_subset=plot_data%>%#
 filter(Disease %in% c("ASCVD","Diabetes","Breast_Cancer","COPD","Atrial_Fib","Prostate_Cancer","Osteoporosis",#
                          "Parkinsons","CKD","Heart_Failure","Rheumatoid_Arthritis","Colorectal_Cancer"))#
  # Define colors for models, now including TD Cox#
  model_colors <- c(#
    "Aladynoulli 1-year" = "#222222", # Black or dark gray#
    "Time-dependent Cox with Noulli" = "#8E44AD",   # Purple#
    "Aladynoulli Dynamic" = "#4285F4",              # Blue#
    "Aladynoulli Static" = "#34A853",               # Green#
    "Cox with Noulli" = "#EA4335",                  # Red#
    "Cox without Noulli" = "#FBBC05"                # Yellow/Orange#
  )#
  # Create the faceted plot#
  p <- ggplot(plot_data_subset, aes(x = model, y = auc, color = model)) +#
    geom_point(size = 2) +#
    geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1) +#
    facet_wrap(~ Disease, scales = "free_y", ncol = 4) +#
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray70") +#
    scale_color_manual(values = model_colors) +#
    scale_y_continuous(limits = c(0.3, 1), breaks = seq(0.3, 1, by = 0.1)) +#
    labs(#
      title = "Multi-Disease AUC Comparison",#
      subtitle = "Performance across top 16 diseases",#
      y = "AUC (95% CI)",#
      x = NULL#
    ) +#
    theme_minimal() +#
    theme(#
      legend.position = "top",#
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),#
      strip.text = element_text(face = "bold"),#
      plot.title = element_text(size = 14, face = "bold"),#
      plot.subtitle = element_text(size = 12)#
    )#
  return(p)#
}
model_data <- parse_model_data("all_model_comp_withtdcox2.csv")#
plot_data <- prepare_forest_plot_data(model_data)#
#
# Add this line to also generate the faceted plot#
faceted_plot <- create_faceted_forest_plot(plot_data)#
ggsave("multidisease_faceted_plot.pdf", faceted_plot, width = 12, height = 12, dpi = 300)#
# Function for time-dependent Cox modeling
head(model_data)
faceted_plot
df=read.csv("all_model_comp_withtdcox2.csv")
head(df)
one_year_combined <- paste0(df$Dynamic1year, " ", trimws(df[[which(names(df) == "Dynamic1year") + 1]]))
head(one_year_combined)
one_year_ci <- lapply(one_year_combined, extract_ci)#
  model_data$one_year_auc <- sapply(one_year_ci, function(x) x[1])#
  model_data$one_year_lower <- sapply(one_year_ci, function(x) x[2])#
  model_data$one_year_upper <- sapply(one_year_ci, function(x) x[3])
# Extract confidence intervals from the formatted strings#
  extract_ci <- function(ci_str) {#
    # Matches format like "0.765 (0.748-0.782)"#
    pattern <- "(\\d+\\.\\d+)\\s*\\((\\d+\\.\\d+)-(\\d+\\.\\d+)\\)"#
    matches <- regexec(pattern, ci_str)#
    result <- regmatches(ci_str, matches)#
    if(length(result) > 0 && length(result[[1]]) >= 4) {#
      return(c(as.numeric(result[[1]][2]), #
               as.numeric(result[[1]][3]),#
               as.numeric(result[[1]][4])))#
    } else {#
      return(c(NA, NA, NA))#
    }#
  }
one_year_ci <- lapply(one_year_combined, extract_ci)
one_year_ci
one_year_combined
one_year_ci
head(df$Dynamic1year)
df
one_year_str <- gsub('[]', '-', as.character(df$Dynamic1year))#
  one_year_ci <- lapply(one_year_str, extract_ci)#
  model_data$one_year_auc <- sapply(one_year_ci, function(x) x[1])#
  model_data$one_year_lower <- sapply(one_year_ci, function(x) x[2])#
  model_data$one_year_upper <- sapply(one_year_ci, function(x) x[3])
one_year_str
head(df)
one_year_ci_str <- gsub("[\u2013\u2014]", "-", as.character(df$X.2))#
  extract_ci <- function(ci_str) {#
    pattern <- "\\((\\d+\\.\\d+)-(\\d+\\.\\d+)\\)"#
    matches <- regexec(pattern, ci_str)#
    result <- regmatches(ci_str, matches)#
    if(length(result) > 0 && length(result[[1]]) >= 3) {#
      return(c(as.numeric(result[[1]][2]), as.numeric(result[[1]][3])))#
    } else {#
      return(c(NA, NA))#
    }#
  }
library(survival)#
library(broom)#
library(dplyr)#
#
FH_processed = read.csv('/Users/sarahurbut/Library/CloudStorage/Dropbox/baselinagefamh.csv')#
#
######
#
disease_names = readRDS("~/aladynoulli2/pyScripts/ukb_model.rds")$disease_names[, 1]#
train_indices = 20001:30000#
major_diseases <- list(#
  ASCVD = c(#
    "Myocardial infarction",#
    "Coronary atherosclerosis",#
    "Other acute and subacute forms of ischemic heart disease",#
    "Unstable angina (intermediate coronary syndrome)",#
    "Angina pectoris",#
    "Other chronic ischemic heart disease, unspecified"#
  ),#
  Diabetes = c("Type 2 diabetes"),#
  Atrial_Fib = c("Atrial fibrillation and flutter"),#
  CKD = c("Chronic renal failure [CKD]", "Chronic Kidney Disease, Stage III"),#
  All_Cancers = c(#
    "Colon cancer",#
    "Malignant neoplasm of rectum, rectosigmoid junction, and anus",#
    "Cancer of bronchus; lung",#
    "Breast cancer [female]",#
    "Malignant neoplasm of female breast",#
    "Cancer of prostate",#
    "Malignant neoplasm of bladder",#
    "Secondary malignant neoplasm",#
    "Secondary malignancy of lymph nodes",#
    "Secondary malignancy of respiratory organs",#
    "Secondary malignant neoplasm of digestive systems",#
    "Secondary malignant neoplasm of liver",#
    "Secondary malignancy of bone"#
  ),#
  Stroke = c(#
    "Cerebral artery occlusion, with cerebral infarction",#
    "Cerebral ischemia"#
  ),#
  Heart_Failure = c("Congestive heart failure (CHF) NOS", "Heart failure NOS"),#
  Pneumonia = c("Pneumonia", "Bacterial pneumonia", "Pneumococcal pneumonia"),#
  COPD = c(#
    "Chronic airway obstruction",#
    "Emphysema",#
    "Obstructive chronic bronchitis"#
  ),#
  Osteoporosis = c("Osteoporosis NOS"),#
  Anemia = c(#
    "Iron deficiency anemias, unspecified or not due to blood loss",#
    "Other anemias"#
  ),#
  Colorectal_Cancer = c(#
    "Colon cancer",#
    "Malignant neoplasm of rectum, rectosigmoid junction, and anus"#
  ),#
  Breast_Cancer = c("Breast cancer [female]", "Malignant neoplasm of female breast"),#
  Prostate_Cancer = c("Cancer of prostate"),#
  Lung_Cancer = c("Cancer of bronchus; lung"),#
  Bladder_Cancer = c("Malignant neoplasm of bladder"),#
  Secondary_Cancer = c(#
    "Secondary malignant neoplasm",#
    "Secondary malignancy of lymph nodes",#
    "Secondary malignancy of respiratory organs",#
    "Secondary malignant neoplasm of digestive systems"#
  ),#
  Depression = c("Major depressive disorder"),#
  Anxiety = c("Anxiety disorder"),#
  Bipolar_Disorder = c("Bipolar"),#
  Rheumatoid_Arthritis = c("Rheumatoid arthritis"),#
  Psoriasis = c("Psoriasis vulgaris"),#
  Ulcerative_Colitis = c("Ulcerative colitis"),#
  Crohns_Disease = c("Regional enteritis"),#
  Asthma = c("Asthma"),#
  Parkinsons = c("Parkinson's disease"),#
  Multiple_Sclerosis = c("Multiple sclerosis"),#
  Thyroid_Disorders = c(#
    "Thyrotoxicosis with or without goiter",#
    "Secondary hypothyroidism",#
    "Hypothyroidism NOS"#
  )#
)#
disease_mapping = list(#
  ASCVD = c('heart_disease', 'heart_disease.1'),#
  Stroke = c('stroke', 'stroke.1'),#
  Diabetes = c('diabetes', 'diabetes.1'),#
  Breast_Cancer = c('breast_cancer', 'breast_cancer.1'),#
  Prostate_Cancer = c('prostate_cancer', 'prostate_cancer.1'),#
  Lung_Cancer = c('lung_cancer', 'lung_cancer.1'),#
  Colorectal_Cancer = c('bowel_cancer', 'bowel_cancer.1'),#
  Depression = character(0),#
  Osteoporosis = character(0),#
  Parkinsons = c('parkinsons', 'parkinsons.1'),#
  COPD = character(0),#
  Anemia = character(0),#
  CKD = character(0),#
  Heart_Failure = c('heart_disease', 'heart_disease.1'),#
  Pneumonia = character(0),#
  Atrial_Fib = character(0),#
  Bladder_Cancer = character(0),#
  Secondary_Cancer = character(0),#
  Anxiety = character(0),#
  Bipolar_Disorder = character(0),#
  Rheumatoid_Arthritis = character(0),#
  Psoriasis = character(0),#
  Ulcerative_Colitis = character(0),#
  Crohns_Disease = character(0),#
  Asthma = character(0),#
  Multiple_Sclerosis = character(0),#
  Thyroid_Disorders = character(0)#
)#
#
fit_cox_baseline_models <- function(Y_train,#
                                    FH_processed,#
                                    train_indices,#
                                    disease_mapping,#
                                    major_diseases,#
                                    disease_names,#
                                    follow_up_duration_years = 10,#
                                    pi_train=NULL) {#
  fitted_models <- list()#
  FH_train <- FH_processed[train_indices, ]#
  #disease_group = "ASCVD"#
  for (disease_group in names(major_diseases)) {#
    ## which fh_cols match#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols))#
      fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, fitting Sex only.\n", disease_group))#
    cat(sprintf(" - Fitting %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_train <- FH_train$sex == target_sex_code#
    } else {#
      mask_train <- rep(TRUE, nrow(FH_train))#
    }#
    current_FH_train <- FH_train[mask_train, ]#
    current_Y_train <- Y_train[mask_train, , , drop = FALSE]#
    print("dim(current_FH_train))")#
    print(dim(current_FH_train))#
    print("dim(current_Y_train)")#
    print(dim(current_Y_train))#
    if (!is.null(pi_train)) {#
      current_pi_train <- pi_train[mask_train, , , drop = FALSE]#
      print("dimPi")#
      print(dim(current_pi_train))#
    } else {#
      current_pi_train <- NULL#
    }#
#
    if (nrow(current_FH_train) == 0) {#
      cat(#
        sprintf(#
          "   Warning: No individuals for target sex code %s in training slice.\n",#
          target_sex_code#
        )#
      )#
      fitted_models[[disease_group]] <- NULL#
      next#
    }#
    # Find disease indices#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    print("disease indices are")#
    print(disease_indices)#
    if (length(disease_indices) == 0) {#
      fitted_models[[disease_group]] <- NULL#
      next#
    }#
    print(disease_names[sort(disease_indices)])#
    print(paste("Total events before filtering:", sum(current_Y_train[, disease_indices, ] == 1)))#
     # Prepare data for Cox model#
    n_age_filtered <- 0#
    n_prevalent <- 0#
    n_no_followup <- 0#
    cox_data <- data.frame()#
    for (i in seq_len(nrow(current_FH_train))) {#
      age_at_enrollment <- current_FH_train$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      # Age filtering#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_train)[3]) {#
        n_age_filtered <- n_age_filtered + 1#
        next#
      }#
      # Prevalent disease check#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_train[i, disease_indices, 1:(t_enroll-1)] == 1)) {#
          n_prevalent <- n_prevalent + 1#
          next#
        }#
      }#
      end_time <- min(t_enroll + follow_up_duration_years,#
                      dim(current_Y_train)[3])#
      ymat <- current_Y_train[i, disease_indices, t_enroll:end_time, drop = TRUE]#
      # Find all event indices (relative to t_enroll)#
      if (length(disease_indices) == 1) {#
        # ymat is a vector#
        event_ages <- which(ymat == 1)#
      } else {#
        # ymat is a matrix#
        event_ages <- which(ymat == 1, arr.ind = TRUE)[, 2]#
      }#
      if (length(event_ages) == 0) {#
        age_at_event <- end_time + 29 - 1#
        event <- 0#
      } else {#
        min_event_idx <- min(event_ages)#
        age_at_event <- t_enroll + min_event_idx + 29 - 1#
        event <- 1#
      }#
      age_enroll <- t_enroll + 29#
      # Skip if no follow-up time#
      if (age_enroll >= age_at_event) {#
        n_no_followup <- n_no_followup + 1#
        next#
      }#
      row <- data.frame(#
        age_enroll = t_enroll + 29,#
        age = age_at_event,#
        event = event,#
        sex = current_FH_train$sex[i]#
      )#
      if (length(fh_cols) > 0 &&#
          all(fh_cols %in% colnames(current_FH_train))) {#
        row$fh <- any(current_FH_train[i, fh_cols])#
      }#
      # Add noulli prediction for this person#
      if (!is.null(current_pi_train)) {#
        # Get the noulli prediction for this disease group#
        pi_diseases <- current_pi_train[i, disease_indices, t_enroll]#
        yearly_risk <- 1 - prod(1 - pi_diseases)  # Convert to yearly risk#
        row$noulli_risk <- yearly_risk#
      }#
      cox_data <- rbind(cox_data, row)#
    }#
    print(paste("Excluded due to age:", n_age_filtered))#
    print(paste("Excluded due to prevalent disease:", n_prevalent))#
    print(paste("Excluded due to no follow-up:", n_no_followup))#
    print(paste("Final nrow(cox_data):", nrow(cox_data)))#
    print(paste("Total events before filtering:", sum(current_Y_train[, disease_indices, ] == 1)))#
    print(paste("Total events after filtering:", sum(cox_data$event)))#
    print("first few rows of cox data")#
    print(head(cox_data))#
    if (nrow(cox_data) == 0 || sum(cox_data$event) < 5) {#
      cat(sprintf(#
        "   Warning: Too few events (%d) for %s\n",#
        sum(cox_data$event),#
        disease_group#
      ))#
      fitted_models[[disease_group]] <- NULL#
      next#
    }#
    # Fit Cox model#
    formula_str <- "Surv(age_enroll,age, event) ~ sex"#
    if ("fh" %in% colnames(cox_data))#
      formula_str <- "Surv(age_enroll,age, event) ~ sex + fh"#
    if (!is.na(target_sex_code)) {#
      formula_str <- if ("fh" %in% colnames(cox_data))#
        "Surv(age_enroll,age, event) ~ fh"#
      else#
        "Surv(age_enroll,age,event) ~ 1"#
    }#
    if (!is.null(pi_train) && "noulli_risk" %in% colnames(cox_data))#
      formula_str <- paste(formula_str, "+ noulli_risk")#
    print(formula_str)#
    fit <- try(coxph(as.formula(formula_str), data = cox_data), silent =#
                 TRUE)#
    print(summary(fit))#
    if (inherits(fit, "try-error")) {#
      cat(sprintf("   Error fitting %s: %s\n", disease_group, fit))#
      fitted_models[[disease_group]] <- NULL#
    } else {#
      fitted_models[[disease_group]] <- fit#
      cat(sprintf(#
        "   Model fitted for %s using %d samples.\n",#
        disease_group,#
        nrow(cox_data)#
      ))#
    }#
  }#
  cat("Finished fitting Cox models.\n")#
  return(fitted_models)#
}#
####
#
Y_train=readRDS("/Users/sarahurbut/Library/CloudStorage/Dropbox/ukb_Y_train.rds")#
FH_processed = read.csv('/Users/sarahurbut/Library/CloudStorage/Dropbox/baselinagefamh.csv')#
#
pi_train=readRDS("/Users/sarahurbut/Library/CloudStorage/Dropbox/pi_enroll_sex_20000_30000.rds")
cb = fit_cox_baseline_models(#
  Y_train = Y_train,#
  FH_processed = FH_processed,#
  train_indices = 20001:30000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  #pi_train=pi_train#
)
### test cox models:#
#
library(survival)#
library(pROC)#
rm(Y_train)#
rm(pi_train)#
rm(train_indices)#
Y_test=readRDS("/Users/sarahurbut/aladynoulli2/pyScripts/ukb_Y_test.rds")#
test_cox_baseline_models <- function(Y_test,#
                                     FH_processed,#
                                     test_indices,#
                                     disease_mapping,#
                                     major_diseases,#
                                     disease_names,#
                                     follow_up_duration_years = 10,#
                                     fitted_models,pi_test=NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, fitting Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
      print("dimPi")#
      print(dim(current_pi_test))#
    } else {#
      current_pi_test<- NULL#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    print(paste("After sex filtering:", nrow(current_FH_test)))#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    print(paste("Total events before filtering:", sum(current_Y_test[, disease_indices, ] == 1)))#
    n_age_filtered <- 0#
    n_prevalent <- 0#
    n_no_followup <- 0#
    cox_data <- data.frame()#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) {#
        n_age_filtered <- n_age_filtered + 1#
        next#
      }#
      # Prevalent disease check#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) {#
          n_prevalent <- n_prevalent + 1#
          next#
        }#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      ymat <- current_Y_test[i, disease_indices, t_enroll:end_time, drop = TRUE]#
      # Find all event indices (relative to t_enroll)#
      if (length(disease_indices) == 1) {#
        # ymat is a vector#
        event_ages <- which(ymat == 1)#
      } else {#
        # ymat is a matrix#
        event_ages <- which(ymat == 1, arr.ind = TRUE)[, 2]#
      }#
      if (length(event_ages) == 0) {#
        age_at_event <- end_time + 29 - 1#
        event <- 0#
      } else {#
        min_event_idx <- min(event_ages)#
        age_at_event <- t_enroll + min_event_idx + 29 - 1#
        event <- 1#
      }#
      age_enroll <- t_enroll + 29#
      if (age_enroll >= age_at_event) {#
        n_no_followup <- n_no_followup + 1#
        next#
      }#
      row <- data.frame(#
        age_enroll = age_enroll,#
        age = age_at_event,#
        event = event,#
        sex = current_FH_test$sex[i]#
      )#
      if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
        row$fh <- any(current_FH_test[i, fh_cols])#
      }#
      if (!is.null(pi_test)) {#
        # Get the noulli prediction for this disease group#
        pi_diseases <- current_pi_test[i, disease_indices, t_enroll]#
        yearly_risk <- 1 - prod(1 - pi_diseases)  # Convert to yearly risk#
        row$noulli_risk <- yearly_risk#
      }#
      cox_data <- rbind(cox_data, row)#
    }#
    print(paste("Excluded due to age:", n_age_filtered))#
    print(paste("Excluded due to prevalent disease:", n_prevalent))#
    print(paste("Excluded due to no follow-up:", n_no_followup))#
    print(paste("Final nrow(cox_data):", nrow(cox_data)))#
    print(paste("First few rows of data"))#
    print(head(cox_data))#
    print(paste("Total events before filtering:", sum(current_Y_test[, disease_indices, ] == 1)))#
    print(paste("Total events after filtering:", sum(cox_data$event)))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(cox_data) == 0) next#
    # Predict linear predictor (risk score)#
    risk_score <- predict(fit, newdata = cox_data, type = "lp")#
    # Calculate AUC (using pROC)#
    roc_obj <- roc(cox_data$event, risk_score)#
    auc_val <- auc(roc_obj)#
    print(sprintf("AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    #surv_obj <- Surv(cox_data$age_enroll,cox_data$age, cox_data$event)#
    surv_obj <- Surv(time = 0, time2 = cox_data$age - cox_data$age_enroll, cox_data$event)#
    print(surv_obj)#
    print("risk_score")#
    print(risk_score)#
    	concordance_result <- concordance(surv_obj ~ risk_score,reverse=TRUE)#
    	c_index <-concordance_result$concordance #
    	print(sprintf("C-index for %s: %.3f", disease_group, c_index))#
    	concordance_results[[disease_group]] <- c_index#
  }#
  return(list(auc_results,concordance_results))#
}#
test_indices=0:10000#
auc_results = test_cox_baseline_models(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = test_indices,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = cb,#
  #pi_test=pi_test#
)#
auc_df <- data.frame(#
disease_group = names(auc_results),#
auc = unlist(auc_results)#
)
test_cox_baseline_models <- function(Y_test,#
                                     FH_processed,#
                                     test_indices,#
                                     disease_mapping,#
                                     major_diseases,#
                                     disease_names,#
                                     follow_up_duration_years = 10,#
                                     fitted_models,pi_test=NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, fitting Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
      print("dimPi")#
      print(dim(current_pi_test))#
    } else {#
      current_pi_test<- NULL#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    print(paste("After sex filtering:", nrow(current_FH_test)))#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    print(paste("Total events before filtering:", sum(current_Y_test[, disease_indices, ] == 1)))#
    n_age_filtered <- 0#
    n_prevalent <- 0#
    n_no_followup <- 0#
    cox_data <- data.frame()#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) {#
        n_age_filtered <- n_age_filtered + 1#
        next#
      }#
      # Prevalent disease check#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) {#
          n_prevalent <- n_prevalent + 1#
          next#
        }#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      ymat <- current_Y_test[i, disease_indices, t_enroll:end_time, drop = TRUE]#
      # Find all event indices (relative to t_enroll)#
      if (length(disease_indices) == 1) {#
        # ymat is a vector#
        event_ages <- which(ymat == 1)#
      } else {#
        # ymat is a matrix#
        event_ages <- which(ymat == 1, arr.ind = TRUE)[, 2]#
      }#
      if (length(event_ages) == 0) {#
        age_at_event <- end_time + 29 - 1#
        event <- 0#
      } else {#
        min_event_idx <- min(event_ages)#
        age_at_event <- t_enroll + min_event_idx + 29 - 1#
        event <- 1#
      }#
      age_enroll <- t_enroll + 29#
      if (age_enroll >= age_at_event) {#
        n_no_followup <- n_no_followup + 1#
        next#
      }#
      row <- data.frame(#
        age_enroll = age_enroll,#
        age = age_at_event,#
        event = event,#
        sex = current_FH_test$sex[i]#
      )#
      if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
        row$fh <- any(current_FH_test[i, fh_cols])#
      }#
      if (!is.null(pi_test)) {#
        # Get the noulli prediction for this disease group#
        pi_diseases <- current_pi_test[i, disease_indices, t_enroll]#
        yearly_risk <- 1 - prod(1 - pi_diseases)  # Convert to yearly risk#
        row$noulli_risk <- yearly_risk#
      }#
      cox_data <- rbind(cox_data, row)#
    }#
    print(paste("Excluded due to age:", n_age_filtered))#
    print(paste("Excluded due to prevalent disease:", n_prevalent))#
    print(paste("Excluded due to no follow-up:", n_no_followup))#
    print(paste("Final nrow(cox_data):", nrow(cox_data)))#
    print(paste("First few rows of data"))#
    print(head(cox_data))#
    print(paste("Total events before filtering:", sum(current_Y_test[, disease_indices, ] == 1)))#
    print(paste("Total events after filtering:", sum(cox_data$event)))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(cox_data) == 0) next#
    # Predict linear predictor (risk score)#
    risk_score <- predict(fit, newdata = cox_data, type = "lp")#
    # Calculate AUC (using pROC)#
    roc_obj <- roc(cox_data$event, risk_score)#
    auc_val <- auc(roc_obj)#
    print(sprintf("AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    #surv_obj <- Surv(cox_data$age_enroll,cox_data$age, cox_data$event)#
    surv_obj <- Surv(time = cox_data$age - cox_data$age_enroll, cox_data$event)#
    print(surv_obj)#
    print("risk_score")#
    print(risk_score)#
    	concordance_result <- concordance(surv_obj ~ risk_score,reverse=TRUE)#
    	c_index <-concordance_result$concordance #
    	print(sprintf("C-index for %s: %.3f", disease_group, c_index))#
    	concordance_results[[disease_group]] <- c_index#
  }#
  return(list(auc_results,concordance_results))#
}
test_indices=0:10000#
auc_results = test_cox_baseline_models(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = test_indices,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = cb,#
  #pi_test=pi_test#
)#
auc_df <- data.frame(#
disease_group = names(auc_results),#
auc = unlist(auc_results)#
)
auc_df_with_noulli <- data.frame(#
disease_group = names(auc_results[[1]]),#
auc = unlist(auc_results[[1]])#
)#
concordance_df_with_noulli <- data.frame(#
disease_group = names(auc_results[[2]]),#
concordance = unlist(auc_results[[2]])#
)
concordance_df_with_noulli
auc_df_with_noulli
write.csv(auc_df_with_noulli,"~/Library/CloudStorage/Dropbox/auc_results_cox_20000_30000train_0_10000test_with_noulli.csv",quote = FALSE)#
#
write.csv(concordance_df_with_noulli,"~/Library/CloudStorage/Dropbox/concordance_results_cox_20000_30000train_0_10000test_with_noulli.csv",quote = FALSE)
ls()
ukb_params=readRDS("ukb_params.rds")
ukb_params=readRDS("~ukb_params.rds")
modl=readRDS("allmodels.rds")
modl
modl[,-4]
load("/Users/sarahurbut/Documents/Documents - Sarahs MacBook Pro/backupfromTM/dynamichr/output/hazards_rate_lowerbound_amit_EQ.rds")
hazards=readDS("~/Documents/Documents - Sarahs MacBook Pro/backupfromTM/dynamichr/output/hazards_rate_UKB_amit_EQ.rds")
hazards=readRDS("~/Documents/Documents - Sarahs MacBook Pro/backupfromTM/dynamichr/output/hazards_rate_UKB_amit_EQ.rds")
head(hazards)
hazards[,'prs.HR']
hazards[,'prs.HR'][1]/
``
dim(hazards)
hazards[,'prs.HR'][1]/hazards[,'prs.HR'][30]
hazards[,'prs.HR'][30]/hazards[,'prs.HR'][1]
tdc
fitted
tdcmodels=readRDS("~/Library/CloudStorage/Dropbox/tdcmodels.rds")
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
#### Testing function#
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
  return(list(auc_results,concordance_results))#
}#
#
# Example usage:#
# Load the time-varying probabilities#
Y_train=readRDS("/Users/sarahurbut/Library/CloudStorage/Dropbox/ukb_Y_train.rds")#
Y_test=readRDS("/Users/sarahurbut/Library/CloudStorage/Dropbox/ukb_Y_test")
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
  return(list(auc_results,concordance_results))#
}#
#
# Example usage:
Y_train=readRDS("/Users/sarahurbut/Library/CloudStorage/Dropbox/ukb_Y_train.rds")#
Y_test=readRDS("ukb_Y_test.rds")
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdcmodels,#
  pi_test = pi_test_full#
)
# Now we can use both pi files with the time-dependent Cox model#
pi_train_full <- readRDS("/Users/sarahurbut/Library/CloudStorage/Dropbox/pi_full_sex_20000_30000.rds")#
pi_test_full <- readRDS("/Users/sarahurbut/Library/CloudStorage/Dropbox/pi_full_sex_0_10000.rds")
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdcmodels,#
  pi_test = pi_test_full#
)
tdc_c_df <- data.frame(#
  disease_group = names(tdc_auc_results[[2]]),#
  c = unlist(tdc_auc_results[[2]])#
)
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdcmodels,#
  pi_test = pi_test_full#
)
auc_results <- results$auc_results#
concordance_results <- results$concordance_results#
tdc_data_list <- results$tdc_data_list#
#
# Now you can easily plot ROC curves for any disease#
library(pROC)#
library(ggplot2)#
#
# Example: Plot ROC curve for ASCVD#
disease <- "ASCVD"#
tdc_data <- tdc_data_list[[disease]]#
risk_scores <- predict(fitted_models[[disease]], newdata = tdc_data, type = "risk")#
person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
#
roc_obj <- roc(person_events$x, person_risks$x)#
plot(roc_obj, main = paste("ROC Curve for", disease))
results=tdc_auc_results;auc_results <- results$auc_results#
concordance_results <- results$concordance_results#
tdc_data_list <- results$tdc_data_list#
#
# Now you can easily plot ROC curves for any disease#
library(pROC)#
library(ggplot2)#
#
# Example: Plot ROC curve for ASCVD#
disease <- "ASCVD"#
tdc_data <- tdc_data_list[[disease]]#
risk_scores <- predict(fitted_models[[disease]], newdata = tdc_data, type = "risk")#
person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
#
roc_obj <- roc(person_events$x, person_risks$x)#
plot(roc_obj, main = paste("ROC Curve for", disease))
fitted_models=tdcmodels
results=tdc_auc_results;auc_results <- results$auc_results#
concordance_results <- results$concordance_results#
tdc_data_list <- results$tdc_data_list#
#
# Now you can easily plot ROC curves for any disease#
library(pROC)#
library(ggplot2)#
#
# Example: Plot ROC curve for ASCVD#
disease <- "ASCVD"#
tdc_data <- tdc_data_list[[disease]]#
risk_scores <- predict(fitted_models[[disease]], newdata = tdc_data, type = "risk")#
person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
#
roc_obj <- roc(person_events$x, person_risks$x)#
plot(roc_obj, main = paste("ROC Curve for", disease))
dim(FH_processed)
head(FH_processed)
pce_data = readRDS('/Users/sarahurbut/Library/Cloudstorage/Dropbox/pce_df_prevent.rds')
head(pce_data)
dim(pce_data)
FH_processed=merge(FH_processed,pce_data,by.x="identifier",by.y="id",all.x=TRUE)
head(FH_processed)
FH_processed[9995:10005,]
saveRDS(FH_processed,"FH_Processedwithprevent.rds")
head(FH_r)
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull [tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}#
#
# Example usage:#
# Load the time-varying probabilities
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdcmodels,#
  pi_test = pi_test_full#
)
dim(Y_test)
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull [tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdcmodels,#
  pi_test = pi_test_full#
)
current_FH_test
FH_test
ls()
FH_test=FH_processed[1:10000,]
#### Testing function#
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull#
        tdc_data$prevent_score <- current_FH_test$prevent_impute#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}#
#
# Example usage:#
# Load the time-varying probabilities
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdcmodels,#
  pi_test = pi_test_full#
)
current_FH_test
head(FH_test)
disease_group="ASCVD"
test_indices
auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]
head(FH_test)
if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }
mask_test <- rep(TRUE, nrow(FH_test))
head(mask_test)
current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]
head(current_Y_test)
if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }
pi_test=pi_test_full
if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }
disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next
disease_indices
start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))
head(current_FH)
head(FH_processed)
names(FH_processed)[2]="age"
s#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      at(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}#
#
# Example usage:#
# Load the time-varying probabilities
t Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))
# Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data
fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      at(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))
pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]
fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
      at(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))
fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))
auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]
fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))
fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))
disease_indices
# Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()
start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }
fh_cols
# Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }
head(tdc_auc_results   # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
)
# After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))
fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
      if (disease_group == "ASCVD") {#
        tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
        tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}
t Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
#### Testing function#
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    #if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
     # if (disease_group == "ASCVD") {#
      #  tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
       # tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      #}#
      # Add other disease-specific scores as needed#
    #}#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}#
#
# Example usage:#
# Load the ti
t Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
#### Testing function#
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
     if (disease_group == "ASCVD") {#
      tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
       tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}#
#
# Example usage:
t Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
dim(tdc_df)
dim(tdc_data)
head(tdc_data$id)
head(tdc_data)
total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))
head(current_FH_test)
i
age_at_enrollment
t_enroll
end_time
follow_up_duration_year
follow_up_duration_years
follow_up_durations_years
follow_up_duration_years=10
for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }
for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }
print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))
start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }
head(tdc_data)
# After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
     if (disease_group == "ASCVD") {#
      tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id]#
       tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id]#
      }#
      # Add other disease-specific scores as needed#
    }
current_FH_test$pce_goff_fuull[tdc_data$id]
tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id + 1]#
tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id + 1]
head(tdc_data)
#### Testing function#
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows)#
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
#
       # After creating tdc_data, add PCE and PREVENT scores#
    if (!is.null(current_FH_test)) {#
      # Get the relevant scores for this disease#
     if (disease_group == "ASCVD") {#
      tdc_data$pce_score <- current_FH_test$pce_goff_fuull[tdc_data$id+1]#
       tdc_data$prevent_score <- current_FH_test$prevent_impute[tdc_data$id+1]#
      }#
      # Add other disease-specific scores as needed#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
       tdc_data_list[[disease_group]] <- tdc_data#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
tdc_models=tdcmodels
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
results=tdc_auc_results;auc_results <- results$auc_results#
concordance_results <- results$concordance_results#
tdc_data_list <- results$tdc_data_list#
#
# Now you can easily plot ROC curves for any disease#
library(pROC)#
library(ggplot2)#
#
# Example: Plot ROC curve for ASCVD#
disease <- "ASCVD"#
tdc_data <- tdc_data_list[[disease]]#
risk_scores <- predict(fitted_models[[disease]], newdata = tdc_data, type = "risk")#
person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
#
roc_obj <- roc(person_events$x, person_risks$x)#
plot(roc_obj, main = paste("ROC Curve for", disease))
disease <- "ASCVD"#
tdc_data <- tdc_data_list[[disease]]#
#
# 1. Get per-person event status#
person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
#
# 2. Get per-person risk scores for each model#
# Your model (Noulli)#
risk_scores <- predict(fitted_models[[disease]], newdata = tdc_data, type = "risk")#
person_noulli_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
#
# PREVENT (static, so just take the unique value per person)#
person_prevent_risks <- aggregate(tdc_data$prevent_score, by = list(id = tdc_data$id), FUN = function(x) unique(x)[1])#
#
# PCE (static, so just take the unique value per person)#
person_pce_risks <- aggregate(tdc_data$pce_score, by = list(id = tdc_data$id), FUN = function(x) unique(x)[1])#
#
# 3. Calculate ROC objects#
roc_noulli <- roc(person_events$x, person_noulli_risks$x)#
roc_prevent <- roc(person_events$x, person_prevent_risks$x)#
roc_pce <- roc(person_events$x, person_pce_risks$x)#
#
# 4. Plot all ROC curves together#
plot(roc_noulli, col = "blue", lwd = 2, main = paste("ROC Curves for", disease))#
lines(roc_prevent, col = "red", lwd = 2)#
lines(roc_pce, col = "green", lwd = 2)#
legend("bottomright",#
       legend = c(#
         sprintf("Noulli (AUC = %.3f)", auc(roc_noulli)),#
         sprintf("PREVENT (AUC = %.3f)", auc(roc_prevent)),#
         sprintf("PCE (AUC = %.3f)", auc(roc_pce))#
       ),#
       col = c("blue", "red", "green"),#
       lwd = 2)
head(person_prevent_risks)
tail(person_prevent_risks)
head(tdc_data[tdc_data$id==9995,c("id","prevent_score")])#
current_FH_test$prevent_impute[9995+1]#Ifidis0-based
head(tdc_data)
head(tdc_data[tdc_data$id==9995,c("id","prevent_score")])
head(tdc_data[tdc_data$id==9995,c("id","prevent_score")])
head(tdc_data[tdc_data$id==9995,])
head(FH_processed)
head(FH_processed[FH_processed$])current_FH_test$prevent_impute[9995 + 1]
current_FH_test$prevent_impute[9995 + 1]
tdc_data$id
head(tdc_data$id)
head(tdc_data)
# Function to evaluate time-dependent Cox models#
test_time_dependent_cox <- function(Y_test,#
                                  FH_processed,#
                                  test_indices,#
                                  disease_mapping,#
                                  major_diseases,#
                                  disease_names,#
                                  follow_up_duration_years = 10,#
                                  fitted_models,#
                                  pi_test = NULL) {#
  auc_results <- list()#
  concordance_results=list()#
  tdc_data_list <- list()  # New list to store tdc_data for each disease#
  FH_test <- FH_processed[test_indices, ]#
  for (disease_group in names(major_diseases)) {#
    fh_cols <- disease_mapping[[disease_group]]#
    if (is.null(fh_cols)) fh_cols <- character(0)#
    if (length(fh_cols) == 0)#
    cat(sprintf(" - %s: No FH columns, evaluating Sex only.\n", disease_group))#
    cat(sprintf(" - Evaluating time-dependent Cox for %s...\n", disease_group))#
    target_sex_code <- NA#
    if (disease_group == "Breast_Cancer")#
      target_sex_code <- 0#
    if (disease_group == "Prostate_Cancer")#
      target_sex_code <- 1#
    if (!is.na(target_sex_code)) {#
      mask_test <- FH_test$sex == target_sex_code#
    } else {#
      mask_test <- rep(TRUE, nrow(FH_test))#
    }#
    current_FH_test <- FH_test[mask_test, ]#
    current_Y_test <- Y_test[mask_test, , , drop = FALSE]#
    if (!is.null(pi_test)) {#
      current_pi_test <- pi_test[mask_test, , , drop = FALSE]#
    } else {#
      current_pi_test <- NULL#
    }#
    if (nrow(current_FH_test) == 0) {#
      cat(sprintf("   Warning: No individuals for target sex code %s in testing slice.\n", target_sex_code))#
      next#
    }#
    disease_indices <- unlist(lapply(major_diseases[[disease_group]], function(disease) {#
      which(tolower(disease_names) == tolower(disease))#
    }))#
    if (length(disease_indices) == 0) next#
    # Create time-dependent data structure for testing#
    print("Calculating total rows needed...")#
    start_time <- Sys.time()#
    total_rows <- 0#
    for (i in seq_len(nrow(current_FH_test))) {#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      # Check for events to determine actual number of rows needed#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        total_rows <- total_rows + 1#
        if (event) break#
      }#
    }#
    print(paste("Total rows needed:", total_rows))#
    print(paste("Time for row calculation:", Sys.time() - start_time))#
    # Pre-allocate data frame#
    print("Pre-allocating data frame...")#
    start_time <- Sys.time()#
    tdc_data <- data.frame(#
      id = integer(total_rows),#
      start = numeric(total_rows),#
      stop = numeric(total_rows),#
      event = logical(total_rows),#
      sex = integer(total_rows),#
      identifier = integer(total_rows) #
    )#
    if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
      tdc_data$fh <- logical(total_rows)#
    }#
    if (!is.null(current_pi_test)) {#
      tdc_data$noulli_risk <- numeric(total_rows)#
    }#
    print(paste("Time for pre-allocation:", Sys.time() - start_time))#
    # Fill the data frame#
    print("Filling data frame...")#
    start_time <- Sys.time()#
    row_idx <- 1#
    for (i in seq_len(nrow(current_FH_test))) {#
      if (i %% 1000 == 0) {#
        print(paste("Processing individual", i, "of", nrow(current_FH_test)))#
        print(paste("Time so far:", Sys.time() - start_time))#
      }#
      age_at_enrollment <- current_FH_test$age[i]#
      t_enroll <- as.integer(age_at_enrollment - 29)#
      if (t_enroll < 0 || t_enroll >= dim(current_Y_test)[3]) next#
      if (length(disease_indices) == 1 && t_enroll > 0) {#
        if (any(current_Y_test[i, disease_indices, 1:(t_enroll-1)] == 1)) next#
      }#
      end_time <- min(t_enroll + follow_up_duration_years, dim(current_Y_test)[3])#
      for (t in t_enroll:(end_time-1)) {#
        ymat <- current_Y_test[i, disease_indices, t:(t+1), drop = TRUE]#
        event <- if (length(disease_indices) == 1) {#
          any(ymat == 1)#
        } else {#
          any(ymat == 1)#
        }#
        # Debug prints for events#
        if (event) {#
          print(paste("Found event for person", i, "at age", t + 30))#
          print("Event matrix:")#
          print(ymat)#
          print("Disease indices:")#
          print(disease_indices)#
        }#
        tdc_data$id[row_idx] <- i#
        tdc_data$start[row_idx] <- t + 29#
        tdc_data$stop[row_idx] <- t + 30#
        tdc_data$event[row_idx] <- event#
        tdc_data$sex[row_idx] <- current_FH_test$sex[i]#
        tdc_data$identifier[row_idx] <- current_FH_test$identifier[i]  # <-- assign here#
    ##
        if (length(fh_cols) > 0 && all(fh_cols %in% colnames(current_FH_test))) {#
          tdc_data$fh[row_idx] <- any(current_FH_test[i, fh_cols])#
        }#
        if (!is.null(current_pi_test)) {#
          pi_diseases <- current_pi_test[i, disease_indices, t]#
          yearly_risk <- 1 - prod(1 - pi_diseases)#
          tdc_data$noulli_risk[row_idx] <- yearly_risk#
        }#
        row_idx <- row_idx + 1#
        if (event) {#
          print(paste("Stopping after event for person", i))#
          break#
        }#
      }#
    }#
    print(paste("Total time for filling:", Sys.time() - start_time))#
    print(paste("Final row count:", row_idx-1))#
    print("Trimming unused rows...")#
    start_time <- Sys.time()#
    tdc_data <- tdc_data[1:(row_idx-1), ]#
#
  tdc_data$pce_score <- current_FH_test$pce_goff_fuull[match(tdc_data$identifier, current_FH_test$identifier)]#
  tdc_data$prevent_score <- current_FH_test$prevent_impute[match(tdc_data$identifier, current_FH_test$identifier)]#
#
 tdc_data_list[[disease_group]] <- tdc_data#
    print(paste("Time for trimming:", Sys.time() - start_time))#
    print("Data frame complete")#
    print(paste("Number of events:", sum(tdc_data$event)))#
    print(paste("Number of unique individuals:", length(unique(tdc_data$id))))#
    print(paste("Average rows per person:", nrow(tdc_data)/length(unique(tdc_data$id))))#
    print(paste("Number of people with events:", sum(tdc_data$event)))#
    print(paste("Proportion of people with events:", sum(tdc_data$event)/length(unique(tdc_data$id))))#
    fit <- fitted_models[[disease_group]]#
    if (is.null(fit) || nrow(tdc_data) == 0) next#
    # Predict risk scores#
    risk_scores <- predict(fit, newdata = tdc_data, type = "risk")#
    # Suppose tdc_data has columns: id, start, stop, event, predicted_risk#
surv_obj <- with(tdc_data, Surv(start, stop, event))#
c_index <- concordance(surv_obj ~ risk_scores, data = tdc_data,reverse=TRUE)$concordance#
print(sprintf("Time-dependent C-index: %.3f", c_index))#
#
    # Calculate time-dependent AUC#
    # For simplicity, we'll use the average risk score per person### NO we should use the concordance ... #
    person_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
    person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
    roc_obj <- roc(person_events$x, person_risks$x)#
    auc_val <- auc(roc_obj)#
    print(sprintf("Time-dependent AUC for %s: %.3f", disease_group, auc_val))#
    auc_results[[disease_group]] <- auc_val#
    concordance_results[[disease_group]]=c_index#
  }#
    # Return all results including the tdc_data_list#
  return(list(auc_results = auc_results, #
              concordance_results = concordance_results,#
              tdc_data_list = tdc_data_list))#
}
# Evaluate time-dependent Cox models#
tdc_auc_results <- test_time_dependent_cox(#
  Y_test = Y_test,#
  FH_processed = FH_processed,#
  test_indices = 0:10000,#
  disease_mapping = disease_mapping,#
  major_diseases = major_diseases,#
  disease_names = disease_names,#
  follow_up_duration_years = 10,#
  fitted_models = tdc_models,#
  pi_test = pi_test_full#
)
head(tdc_data)
disease <- "ASCVD"#
tdc_data <- tdc_data_list[[disease]]
results=tdc_auc_results
auc_results <- results$auc_results#
concordance_results <- results$concordance_results#
tdc_data_list <- results$tdc_data_list
tdc_data_list[["ASCVD"]]
tail(tdc_data_list[["ASCVD"]])
head(tdc_data_list[["ASCVD"]])
tail(pce_data)
. Get per-person event status#
person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
#
# 2. Get per-person risk scores for each model#
# Your model (Noulli)#
risk_scores <- predict(fitted_models[[disease]], newdata = tdc_data, type = "risk")#
person_noulli_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
#
# PREVENT (static, so just take the unique value per person)#
person_prevent_risks <- aggregate(tdc_data$prevent_score, by = list(id = tdc_data$id), FUN = function(x) unique(x)[1])#
#
# PCE (static, so just take the unique value per person)#
person_pce_risks <- aggregate(tdc_data$pce_score, by = list(id = tdc_data$id), FUN = function(x) unique(x)[1])#
#
# 3. Calculate ROC objects#
roc_noulli <- roc(person_events$x, person_noulli_risks$x)#
roc_prevent <- roc(person_events$x, person_prevent_risks$x)#
roc_pce <- roc(person_events$x, person_pce_risks$x)#
#
# 4. Plot all ROC curves together#
plot(roc_noulli, col = "blue", lwd = 2, main = paste("ROC Curves for", disease))#
lines(roc_prevent, col = "red", lwd = 2)#
lines(roc_pce, col = "green", lwd = 2)#
legend("bottomright",#
       legend = c(#
         sprintf("Noulli (AUC = %.3f)", auc(roc_noulli)),#
         sprintf("PREVENT (AUC = %.3f)", auc(roc_prevent)),#
         sprintf("PCE (AUC = %.3f)", auc(roc_pce))#
       ),#
       col = c("blue", "red", "green"),#
       lwd = 2)
tdc_data=tdc_data_list[["ASCVD"]])
tdc_data=tdc_data_list[["ASCVD"]]
. Get per-person event status#
person_events <- aggregate(tdc_data$event, by = list(id = tdc_data$id), FUN = max)#
#
# 2. Get per-person risk scores for each model#
# Your model (Noulli)#
risk_scores <- predict(fitted_models[[disease]], newdata = tdc_data, type = "risk")#
person_noulli_risks <- aggregate(risk_scores, by = list(id = tdc_data$id), FUN = mean)#
#
# PREVENT (static, so just take the unique value per person)#
person_prevent_risks <- aggregate(tdc_data$prevent_score, by = list(id = tdc_data$id), FUN = function(x) unique(x)[1])#
#
# PCE (static, so just take the unique value per person)#
person_pce_risks <- aggregate(tdc_data$pce_score, by = list(id = tdc_data$id), FUN = function(x) unique(x)[1])#
#
# 3. Calculate ROC objects#
roc_noulli <- roc(person_events$x, person_noulli_risks$x)#
roc_prevent <- roc(person_events$x, person_prevent_risks$x)#
roc_pce <- roc(person_events$x, person_pce_risks$x)#
#
# 4. Plot all ROC curves together#
plot(roc_noulli, col = "blue", lwd = 2, main = paste("ROC Curves for", disease))#
lines(roc_prevent, col = "red", lwd = 2)#
lines(roc_pce, col = "green", lwd = 2)#
legend("bottomright",#
       legend = c(#
         sprintf("Noulli (AUC = %.3f)", auc(roc_noulli)),#
         sprintf("PREVENT (AUC = %.3f)", auc(roc_prevent)),#
         sprintf("PCE (AUC = %.3f)", auc(roc_pce))#
       ),#
       col = c("blue", "red", "green"),#
       lwd = 2)
ls()
head(tdc_data)
head(plot_data)
head(model_data)
model_data <- parse_model_data("allmodels.rds")#
#
model_data$tdc_cox_cstat <- as.numeric(model_data$tdc_cox_cstat)#
model_data$tdc_cox_lower <- as.numeric(model_data$tdc_cox_lower)#
model_data$tdc_cox_upper <- as.numeric(model_data$tdc_cox_upper)#
#
plot_data <- prepare_forest_plot_data(model_data)
# Alternative approach with facet_wrap for separate panels by disease#
create_faceted_forest_plot <- function(plot_data) {#
  # Limit to top 16 diseases by dynamic AUC#
  top_diseases <- plot_data %>%#
    filter(model == "Aladynoulli Dynamic") %>%#
    arrange(desc(Events)) %>%#
    head(16) %>%#
    pull(Disease)#
  plot_data_subset <- plot_data %>%#
    filter(Disease %in% top_diseases)#
#
  plot_data_subset$Disease <- factor(plot_data_subset$Disease, levels = top_diseases)#
plot_data_subset=plot_data%>%#
 filter(Disease %in% c("ASCVD","Diabetes","Breast_Cancer","COPD","Atrial_Fib","Prostate_Cancer","Osteoporosis",#
                          "Parkinsons","CKD","Heart_Failure","Rheumatoid_Arthritis","Colorectal_Cancer"))#
  # Define colors for models, now including TD Cox#
  model_colors <- c(#
    "Aladynoulli 1-year" = "#222222", # Black or dark gray#
    "Time-dependent Cox with Noulli" = "#8E44AD",#
    "Time-dependent Cox with Noulli c-stat"="blue",# Purple#
    ##"Aladynoulli Dynamic" = "#4285F4",              # Blue#
    "Aladynoulli Static" = "#34A853",               # Green#
    "Cox with Noulli" = "#EA4335",                  # Red#
    "Cox without Noulli" = "#FBBC05"                # Yellow/Orange#
  )#
  plot_data_subset=plot_data_subset[-c("Aladynoulli 1-year","Time-dependent Cox with Noulli c-stat","Aladynoulli Static","Cox with Noulli",#
    "Cox without Noulli"),]#
  # Create the faceted plot#
  p <- ggplot(plot_data_subset, aes(x = model, y = auc, color = model)) +#
    geom_point(size = 2) +#
    geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1) +#
    facet_wrap(~ Disease, scales = "free_y", ncol = 4) +#
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray70") +#
    scale_color_manual(values = model_colors) +#
    scale_y_continuous(limits = c(0.3, 1), breaks = seq(0.3, 1, by = 0.1)) +#
    labs(#
      title = "Multi-Disease AUC Comparison",#
      subtitle = "Performance across top 16 diseases",#
      y = "AUC (95% CI)",#
      x = NULL#
    ) +#
    theme_minimal() +#
    theme(#
      legend.position = "top",#
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),#
      strip.text = element_text(face = "bold"),#
      plot.title = element_text(size = 14, face = "bold"),#
      plot.subtitle = element_text(size = 12)#
    )#
  return(p)#
}
tdc_auc_results
ls()
head(tdc_data)
head(results)
df=fread("~/aladynoulli2/pyScripts/df_ukb_pce.csv")
library(data.table)
df=fread("~/aladynoulli2/pyScripts/df_ukb_pce.csv")
head(df)
dim(df)
sum(is.na(df$pce_goff))
sum(is.na(df$))
head(df)
fh=fread("fh_processed = pd.read_csv('/Users/sarahurbut/Library/Cloudstorage/Dropbox-Personal/baselinagefamh.csv')
fh=fread("fh_processed = pd.read_csv('/Users/sarahurbut/Library/Cloudstorage/Dropbox-Personal/baselinagefamh.csv")
fh=fread("/Users/sarahurbut/Library/Cloudstorage/Dropbox-Personal/baselinagefamh.csv")
head(fh)
dim(fh)
all.equal(fh$age[1:400000],df$age)
plot(fh$age[1:4000000],df$age)
plot(fh$age[1:400000],df$age)
fh[which(fh$age[1:400000]!=df$age),]
df[which(fh$age[1:400000]!=df$age),"age"]
df[which(fh$age[1:400000]!=df$age),]
df[which(fh$age[1:400000]!=df$age),c("Identifier","age")]
fh[which(fh$age[1:400000]!=df$age),]
E=readRDS("E_full_tensor.rds")
head(E)
E[which(fh$age[1:400000]!=df$age),]
cor(fh$age[1:400000],df$age)
pcs=readRDS("~/Library/CloudStorage/Dropbox-Personal/pheno_dir/big_rds/baseline_withPCS.rds")
head(pcs)
pcs[which(fh$age[1:400000]!=df$age),]
fh$identifier[which(fh$age[1:400000]!=df$age),]
fh$identifier[which(fh$age[1:400000]!=df$age)]
pcs[pcs$identifier%In%fh$identifier[which(fh$age[1:400000]!=df$age)]
,]
pcs[pcs$identifier%in%fh$identifier[which(fh$age[1:400000]!=df$age)]
,]
pcs[pcs$identifier%in%fh$identifier[which(fh$age[1:400000]!=df$age)],"f.21022.0.0"]
pcs=readRDS("~/Library/CloudStorage/Dropbox-Personal/pheno_dir/big_rds/dfukbaseline_7.rds
")
pcs=readRDS("~/Library/CloudStorage/Dropbox-Personal/pheno_dir/big_rds/dfukbaseline_7.rds")
pcs[pcs$identifier%in%fh$identifier[which(fh$age[1:400000]!=df$age)],"f.21022.0.0"]
colnames(pcs)
pcs=readRDS("~/Library/CloudStorage/Dropbox-Personal/pheno_dir/output/dfukb_baseline.rds")
pcs[pcs$identifier%in%fh$identifier[which(fh$age[1:400000]!=df$age)],"f.21022.0.0"]
load("/Users/sarahurbut/Library/CloudStorage/Dropbox-Personal/pheno_dir/output/dfukb_baseline_pheno.rds")
pcs=readRDS("~/Library/CloudStorage/Dropbox-Personal/pheno_dir/output/dfukb_baseline_pheno.rds")
sum(fh$identifier[which(fh$age[1:400000]!=df$age))
sum(fh$identifier[which(fh$age[1:400000]!=df$age)
)
sum(fh$age[1:400000]!=df$age)
dim(fh)
head(fh)
head(df)
